Traceback (most recent call last):
  File "/home/runner/.local/lib/python3.12/site-packages/jupyter_core/utils/__init__.py", line 154, in wrapped
    asyncio.get_running_loop()
RuntimeError: no running event loop

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/runner/.local/lib/python3.12/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/home/runner/.local/lib/python3.12/site-packages/nbclient/client.py", line 1319, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/runner/.local/lib/python3.12/site-packages/jupyter_core/utils/__init__.py", line 158, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/lib/python3.12/asyncio/base_events.py", line 687, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/home/runner/.local/lib/python3.12/site-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/home/runner/.local/lib/python3.12/site-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/home/runner/.local/lib/python3.12/site-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import numpy as np
import matplotlib.pyplot as plt
from scipy.special import expit

# Visualize the concept of loss
def visualize_loss_concept():
    fig, axes = plt.subplots(1, 3, figsize=(18, 6))
    
    # Example data
    np.random.seed(42)
    x = np.linspace(0, 10, 20)
    y_true = 2 * x + 1 + np.random.normal(0, 2, len(x))  # True relationship with noise
    
    # Three different model predictions
    models = [
        ("Bad Model", 0.5 * x + 5),
        ("OK Model", 1.5 * x + 2),
        ("Good Model", 2.1 * x + 0.8)
    ]
    
    colors = ['red', 'orange', 'green']
    
    for i, (name, y_pred) in enumerate(models):
        ax = axes[i]
        
        # Plot data and predictions
        ax.scatter(x, y_true, color='blue', alpha=0.7, s=50, label='True Data')
        ax.plot(x, y_pred, color=colors[i], linewidth=3, label=f'{name} Prediction')
        
        # Draw error lines
        for xi, yi_true, yi_pred in zip(x, y_true, y_pred):
            ax.plot([xi, xi], [yi_true, yi_pred], 'k--', alpha=0.5, linewidth=1)
        
        # Calculate and display loss (Mean Squared Error)
        mse = np.mean((y_true - y_pred)**2)
        ax.set_title(f'{name}\nMSE Loss = {mse:.2f}', fontsize=14, fontweight='bold')
        ax.set_xlabel('Input (x)')
        ax.set_ylabel('Output (y)')
        ax.legend()
        ax.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.show()
    
    print("Key Insight: Lower loss = better model performance!")
    print("The loss function gives us a single number to optimize.")

visualize_loss_concept()
------------------


[31m---------------------------------------------------------------------------[39m
[31mModuleNotFoundError[39m                       Traceback (most recent call last)
[36mCell[39m[36m [39m[32mIn[1][39m[32m, line 1[39m
[32m----> [39m[32m1[39m [38;5;28;01mimport[39;00m [34;01mnumpy[39;00m [38;5;28;01mas[39;00m [34;01mnp[39;00m
[32m      2[39m [38;5;28;01mimport[39;00m [34;01mmatplotlib[39;00m[34;01m.[39;00m[34;01mpyplot[39;00m [38;5;28;01mas[39;00m [34;01mplt[39;00m
[32m      3[39m [38;5;28;01mfrom[39;00m [34;01mscipy[39;00m[34;01m.[39;00m[34;01mspecial[39;00m [38;5;28;01mimport[39;00m expit

[31mModuleNotFoundError[39m: No module named 'numpy'

